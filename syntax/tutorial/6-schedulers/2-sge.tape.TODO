# * The resource parameter vmem can be specified as .vmem at task declarations
# * The "cmds" parameter is inserted as a direct string replacement by ducttape
#   and contains the "payload" of this task
# * This assumes that scheduler submission happens asynchronously
#   and that we must poll the scheduler to learn when the job has completed
submitter sge :: CMDS vmem walltime q {
  # TODO: We're still missing a few variables that typically get passed in.
  # SGE: echo "#$-l vmem=$vmem" >> $wrapper
  # SGE:  echo "#-l walltime=$walltime" >> $wrapper
  action wrap > wrapper {
    echo "#PBS -S /bin/bash" >> $jobScript
    echo "#PBS -q $RESOURCE_q" >> $jobScript
    echo "#PBS -l nodes=1:ppn=$RESOURCE_cpus" >> $jobScript
    echo "#PBS -l walltime=$RESOURCE_time" >> $jobScript
    echo "#PBS -j oe" >> $jobScript
    echo "#PBS -o localhost:$PWD/job.out" >> $jobScript
    echo "#PBS -N $CONF_NAME/$TASK_NAME/$REALIZATION" >> $jobScript

    # Bash flags aren't necessarily passed into the scheduler
    # so we must re-initialize them
    echo "set -e # stop on errors" >> $jobScript
    echo "set -o pipefail # stop on pipeline errors" >> $jobScript
    echo "set -u # stop on undeclared variables" >> $jobScript
    echo "set -x # show each command as it is executed" >> $jobScript

    # The current working directory will also be changed by most schedulers
    echo "cd $PWD/work" >> $jobScript

    echo "$CMDS" >> $wrapper
  }
  action run < wrapper > jobid {
    qsub $wrapper > $jobid
  }
  action poll < jobid > done exit_code {
   # Note: This is complicated by having to poll rather than being able to just use SGE's -sync
   jobid=$(echo $jobid | cut -d. -f1) # Remove server name, if specified

   if [[ "$jobid" == "" ]]; then
     echo >&2 "ERROR: Empty job id. Did the job fail to submit?"
     exit 1
   fi

   while true; do
     # Use -alm to avoid costly queries to logs we don't even need
     exit_status=$(tracejob -alm $jobid | awk '/Exit_status=-?[0-9]+/{print $4}' | cut -d= -f2)
     if [[ "$exit_status" != "" ]]; then
	echo >&2 "Job exited with status $exit_status"
	if [[ -e job.out ]]; then
	    cat job.out
	fi
        exit $exit_status
     fi
     sleep 30
    done
  }
  action status > short_status long_status {
    qstat -f $id | awk '/job_state = Q/{print "queued"} /job_state = R/{print "running"}' > $status
  }
}

# NOTE: File transfers and decompression are handled by
# a per-machine limit for each of these tasks and are
# but are not included in the submit-script time
