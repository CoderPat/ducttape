package ducttape.workflow

import collection._
import ducttape.hyperdag.PackedVertex
import ducttape.hyperdag.meta.MetaHyperDag
import ducttape.workflow.Types.UnpackState
import ducttape.workflow.Types.UnpackedWorkVert
import ducttape.workflow.Types.WorkflowEdge
import ducttape.workflow.Types.PackedWorkVert
import ducttape.syntax.AbstractSyntaxTree.Spec
import ducttape.syntax.AbstractSyntaxTree.PackageDef
import ducttape.syntax.AbstractSyntaxTree.SubmitterDef
import ducttape.syntax.AbstractSyntaxTree.VersionerDef
import ducttape.hyperdag.HyperEdge
import ducttape.hyperdag.UnpackedVertex
import ducttape.hyperdag.meta.PhantomMetaHyperDag
import ducttape.hyperdag.meta.UnpackedMetaVertex
import ducttape.hyperdag.walker.UnpackedPhantomMetaDagWalker
import ducttape.hyperdag.walker.PackedPhantomMetaDagWalker
import ducttape.hyperdag.walker.MetaVertexFilter
import ducttape.hyperdag.walker.RealizationMunger
import ducttape.workflow.SpecTypes.SpecPair

import grizzled.slf4j.Logging

trait PlanPolicy;
case class OneOff(graftRelaxations: Map[PackedWorkVert, Set[Branch]]) extends PlanPolicy;
case class VertexFilter(plannedVertices: Set[(String,Realization)]) extends PlanPolicy;
case class PatternFilter(
    planFilter: Map[BranchPoint, Set[String]],
    graftRelaxations: Map[PackedWorkVert, Set[Branch]]
  ) extends PlanPolicy;

object HyperWorkflow {
  type ExplainCallback = (=>String, =>String, Boolean) => Unit
  type UnpackedWalker = UnpackedPhantomMetaDagWalker[TaskTemplate,BranchPoint,BranchInfo,Seq[SpecPair],Branch,UnpackState]
  type HyperWorkflowMunger = RealizationMunger[Option[TaskTemplate], BranchInfo, Seq[SpecPair], Branch, UnpackState]
  
  trait HyperWorkflowStateMunger extends HyperWorkflowMunger {
    
    // heBranch might be None if this vertex has no incoming hyperedge
    override def initHyperedge(heBranch: Option[Branch]): UnpackState = heBranch match {
      case None => new UnpackState
      case Some(branch: Branch) => new UnpackState + ((branch.branchPoint, branch))
    }
    
    override def toRealization(state: UnpackState): Seq[Branch] = state.values.toSeq
  }
}

// final type parameter TaskDef is for storing the source of input edges
// each element of plan is a set of branches that are mutually compatible
// - not specifying a branch point indicates that any value is acceptable
// TODO: Multimap (just use typedef?)
class HyperWorkflow(val dag: PhantomMetaHyperDag[TaskTemplate,BranchPoint,BranchInfo,Seq[SpecPair]],
                    val packageDefs: Map[String,PackageDef],
                    val plans: Seq[RealizationPlan],
                    val submitters: Seq[SubmitterDef], // TODO: Resolve earlier?
                    val versioners: Seq[VersionerDef],
                    val branchPointFactory: BranchPointFactory,
                    val branchFactory: BranchFactory)
    extends Logging {
  
  import HyperWorkflow._

  def packedWalker: PackedPhantomMetaDagWalker[TaskTemplate] = dag.packedWalker

  // TODO: Currently only used by initial pass to find goals
  // TODO: Document different use cases of planFilter vs plannedVertices
  // NOTE: explainCallback can be used to provide the user with
  //       useful information about why certain realizations are not produced
  def NO_EXPLAIN(vertexName: => String, msg: => String, accepted: Boolean) {}
  def unpackedWalker(policy: PlanPolicy,
                     explainCallback: ( =>String, =>String, Boolean) => Unit = NO_EXPLAIN)
                     : UnpackedWalker = {
    
    val ordering: Ordering[Branch] = Ordering.fromLessThan {
      (a: Branch, b: Branch) => a.branchPoint.name < b.branchPoint.name
    }
    
    // TODO: XXX: HACK: This shouldn't be called for nulls generated by epsilons
    def toD(branchInfo: BranchInfo): Branch = if (branchInfo != null) branchInfo.branch else Task.NO_BRANCH
    
    def observe(v: UnpackedVertex[Option[TaskTemplate], BranchInfo, Seq[SpecPair], Branch])
      = explainCallback(v.packed.toString, v.realization.mkString("-"), true)

    // the inPlanConstraint implements both a RealizationMunger and a MetaVertexFilter
    val inPlanConstraint = new InPlanConstraint(policy, explainCallback)
      
    // order is important!
    // we must first apply grafts, *before* enforcing global branch point consistency
    // since some branches may disappear due to grafting
    val munger = new BranchGraftMunger(dag, explainCallback).
      andThen(GlobalBranchPointConstraint).
      andThen(inPlanConstraint)
    dag.unpackedWalker[Branch,UnpackState](munger, inPlanConstraint, toD, observe)(ordering)
  }
}
